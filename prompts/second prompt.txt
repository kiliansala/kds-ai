Venimos de otro proyecto y vamos a continuar aquí. Este repo es una copia de seguridad que he hecho anteriormente. Puedes preparar un plan para actualizar y seguir aquí?

Contexto y objetivo general
- Proyecto KDS-AI: construir un Design System AI-friendly con Figma como Single Source of Truth (SSOT), integrando MCP (Multi-Platform Code) para sincronizar:
  - Web Components base (Lit).
  - Wrappers Angular/React/Blazor generados desde los Web Components.
  - Tokens de diseño extraídos de Figma (niveles primitives/semantic/components).
  - Documentación y pruebas en Storybook + dev-app.
- Figma es el SSOT visual y de tokens; MCP (Code Connect, etc.) se usa para reimportar componentes, mapear props y validar contra Figma.
- Siguiente componente a abordar: Badge (tras Button).

Importación y sincronización desde Figma (MCP)
- Se descargan variables/tokens desde Figma (primitives, semantic, components).
- Code Connect mapea props (ej. Button: props appearance, state, hasIcon, label, icon; wrapper Blazor añadió Href).
- Reimportar componentes desde Figma se hace vía MCP; el flujo asume Figma como origen de verdad visual y de tokens.

Dev-app y Storybook
- Dev-app: muestra tokens (Primitives, Semantic, Components) y sus alias, niveles y CSS vars; permite navegar cadenas de alias (Components → Semantic/Primitive, Semantic → Primitive), ver valores por modo (light/dark) y copiar nombres de variables CSS. Consume el artefacto `src/tokens/tokens-data.json` (no los JSON crudos de Figma).
- Storybook: documenta componentes; debe usar el mismo artefacto `src/tokens/tokens-data.json`. La generación automática de MDX se separa en un script opcional, no en el build de tokens.
- MDX: si se necesitan páginas de tokens/Component Docs, se generan con un script separado (`docs:components`), no durante `tokens:build`.

Flujo de tokens (estado deseado)
- Inputs (descarga desde Figma): `figma/tokens.primitive.json`, `figma/tokens.semantic.json`, `figma/tokens.components.json`.
- Artefacto consumible: `src/tokens/tokens-data.json` (dev-app/Storybook leen de aquí).
- Export W3C (pendiente): saldrá en `dist/` cuando se implemente; se usará la misma lógica de dedupe/alias.
- Dedupe/alias: prioridad Primitive > Semantic > Components; usar `canonicalByKey` y `aliasToCanonical` para resolver cadenas sin duplicados.

Scripts npm (añadir si falta)
- tokens:sync -> `node scripts/sync-tokens.mjs` (descarga Figma -> figma/).
- tokens:build -> `node scripts/generate-token-docs.mjs` (lee figma/*.json, genera src/tokens/tokens-data.json).
- tokens:watch -> `chokidar "figma/tokens.*.json" -c "npm run tokens:build"`.
- docs:components -> `node scripts/generate-component-docs.mjs` (opcional, genera MDX cuando se requiera).

Cambios en scripts
1) scripts/sync-tokens.mjs
   - OUTPUT_DIR = 'figma'; mkdir si falta; guardar como figma/tokens.<name>.json.
2) scripts/generate-token-docs.mjs
   - TOKEN_FILES/TOKEN_ORDER/FILE_PRIORITY/FILE_LEVEL apuntan a figma/... (no a raíz).
   - Generar solo src/tokens/tokens-data.json.
   - Eliminar generación de MDX y logs de componentes dentro de este script.
3) scripts/generate-component-docs.mjs
   - Si no existe, crear: genera MDX desde contrato + src/tokens/tokens-data.json, resolviendo alias/canónicos.
   - Se ejecuta solo con npm run docs:components (no forma parte del build de tokens).
4) README
   - Documentar flujos: tokens:sync, tokens:build, tokens:watch, docs:components.
   - Dev-app/Storybook consumen src/tokens/tokens-data.json; input original viene de figma/tokens.*.json.

Estado previo y mensajes
- El log “Generated documentation for Button...” provenía del bloque MDX dentro de generate-token-docs.mjs; al quitarlo ya no debe tocar MDX ni loguear Button.


Acciones pendientes en el proyecto clonado
- Asegurar scripts y rutas: figma/ como destino de tokens Figma; generate-token-docs.mjs sin generación de MDX; tokens-data en src/tokens.
- Ejecutar en la ruta editable: `npm run tokens:sync` y luego `npm run tokens:build`.
- Si se desea regenerar MDX, usar `npm run docs:components`.
- Revisar cadenas de alias en dev-app/Storybook: Components → Semantic/Primitive, Semantic → Primitive; alias resueltos con prioridad Primitive > Semantic > Components.
- Próximo componente a implementar/documentar: Badge.